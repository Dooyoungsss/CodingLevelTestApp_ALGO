import { GoogleGenAI, Type } from "@google/genai";
import { Problem, Language, AnalysisResult, CodeSubmission } from "../types";

const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

// Constants for prompts
const SYSTEM_INSTRUCTION = `당신은 한국정보올림피아드(KOI), 백준, USACO 수준의 코딩 테스트 출제 및 평가 전문가입니다. 
항상 정확하고 엄격하게 판단하며, 학생의 실력 향상을 위한 건설적인 피드백을 한국어로 제공합니다.`;

export const generateProblems = async (
  language: Language,
  isAssessment: boolean,
  problemCount: number,
  targetLevel?: number
): Promise<Problem[]> => {
  const model = "gemini-2.5-flash";
  
  let promptContext = "";
  if (isAssessment) {
    promptContext = `레벨 1부터 10까지의 난이도 중, 초급(1-3), 중급(4-7), 고급(8-10) 문제를 적절히 섞어서 총 ${problemCount}문제를 출제해주세요. 난이도 분포는 고르게 해주세요.`;
  } else {
    promptContext = `레벨 ${targetLevel} (1-10 척도)에 해당하는 문제를 총 ${problemCount}문제 출제해주세요.`;
  }

  const prompt = `
    다음 요구사항에 맞춰 코딩 테스트 문제를 JSON 형식으로 생성해주세요.
    ${promptContext}
    언어 환경: ${language === 'python' ? 'Python 3' : 'C++17'}
    
    문제 스타일:
    - 한국정보올림피아드(KOI) 1차/2차 대회 스타일
    - 알고리즘적 사고를 요구함 (단순 문법 아님)
    - 입력과 출력 형식이 명확해야 함
  `;

  try {
    const response = await ai.models.generateContent({
      model,
      contents: prompt,
      config: {
        systemInstruction: SYSTEM_INSTRUCTION,
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.ARRAY,
          items: {
            type: Type.OBJECT,
            properties: {
              id: { type: Type.STRING },
              title: { type: Type.STRING },
              description: { type: Type.STRING },
              level: { type: Type.INTEGER },
              inputFormat: { type: Type.STRING },
              outputFormat: { type: Type.STRING },
              constraints: { type: Type.STRING },
              sampleCases: {
                type: Type.ARRAY,
                items: {
                  type: Type.OBJECT,
                  properties: {
                    input: { type: Type.STRING },
                    output: { type: Type.STRING },
                  },
                },
              },
            },
            required: ["id", "title", "description", "level", "inputFormat", "outputFormat", "sampleCases", "constraints"],
          },
        },
      },
    });

    if (response.text) {
      return JSON.parse(response.text) as Problem[];
    }
    throw new Error("No data returned");
  } catch (error) {
    console.error("Failed to generate problems:", error);
    throw error;
  }
};

export const judgeCode = async (
  code: string,
  language: Language,
  problem: Problem,
  input: string,
  expectedOutput: string
): Promise<{ passed: boolean; output: string }> => {
  // Since we cannot run actual C++/Python code in the browser securely without a heavy engine like Pyodide (which is huge) or a backend,
  // We will use Gemini as a "Mock Judge" to simulate execution based on logic.
  // This is acceptable for a "Level Test App" prototype to demonstrate the flow.
  
  const prompt = `
    당신은 엄격한 온라인 저지(Online Judge) 시스템입니다.
    다음 문제를 해결하기 위해 작성된 코드의 실행 결과를 예측하세요.
    
    [문제 정보]
    제목: ${problem.title}
    설명: ${problem.description}
    
    [사용자 코드 (${language})]
    ${code}
    
    [테스트 입력]
    ${input}
    
    [정답 출력]
    ${expectedOutput}
    
    당신의 역할:
    1. 코드를 분석하여 컴파일 에러나 런타임 에러가 있는지 확인하십시오.
    2. 에러가 없다면 위 [테스트 입력]을 넣었을 때 나올 [실제 출력]을 생성하십시오.
    3. [실제 출력]이 [정답 출력]과 논리적으로 일치하는지(공백 등 사소한 차이 무시) 판단하십시오.
    
    결과는 JSON으로만 반환하세요.
  `;

  const response = await ai.models.generateContent({
    model: "gemini-2.5-flash",
    contents: prompt,
    config: {
      responseMimeType: "application/json",
      responseSchema: {
        type: Type.OBJECT,
        properties: {
          passed: { type: Type.BOOLEAN },
          output: { type: Type.STRING, description: "The actual output generated by the user's code, or error message." },
        },
        required: ["passed", "output"],
      },
    },
  });

  if (response.text) {
    return JSON.parse(response.text);
  }
  return { passed: false, output: "Error in judging system." };
};

export const generateAnalysisReport = async (
  submissions: CodeSubmission[],
  problems: Problem[],
  userName: string
): Promise<AnalysisResult> => {
  const prompt = `
    학생 이름: ${userName}
    이 학생이 푼 코딩 테스트 결과를 바탕으로 종합 평가 리포트를 작성해주세요. 
    피드백 작성 시 학생의 이름(${userName})을 부르며 친절하고 전문적으로 조언해주세요.
    
    [문제 및 풀이 데이터]
    ${submissions.map((sub, idx) => `
      문제 ${idx + 1}: ${problems.find(p => p.id === sub.problemId)?.title} (Level ${problems.find(p => p.id === sub.problemId)?.level})
      작성 코드: 
      ${sub.code}
      결과: ${sub.passed ? "정답" : "오답"}
      실행 출력: ${sub.executionOutput}
    `).join("\n\n")}
    
    다음 항목을 포함하여 JSON으로 출력하세요:
    1. totalScore (0-100점)
    2. rankEstimate (예: Bronze, Silver, Gold, Platinum, Diamond 등 KOI/Baekjoon 티어 기준)
    3. strengths (강점 3가지)
    4. weaknesses (약점 3가지)
    5. recommendations (학습 조언 3가지)
    6. detailedFeedback (전체적인 총평 - 마크다운 형식 가능, 학생의 이름을 포함할 것)
    7. levelScores (각 영역/난이도별 점수 - 차트용 데이터. 카테고리 명(level)은 '구현', '자료구조', '수학', '탐색', 'DP' 처럼 반드시 4글자 이내의 짧은 한글 단어로 할 것. 영어 병기 하지 말 것.)
  `;

  const response = await ai.models.generateContent({
    model: "gemini-2.5-flash",
    contents: prompt,
    config: {
      systemInstruction: SYSTEM_INSTRUCTION,
      responseMimeType: "application/json",
      responseSchema: {
        type: Type.OBJECT,
        properties: {
          totalScore: { type: Type.INTEGER },
          rankEstimate: { type: Type.STRING },
          strengths: { type: Type.ARRAY, items: { type: Type.STRING } },
          weaknesses: { type: Type.ARRAY, items: { type: Type.STRING } },
          recommendations: { type: Type.ARRAY, items: { type: Type.STRING } },
          detailedFeedback: { type: Type.STRING },
          levelScores: {
            type: Type.ARRAY,
            items: {
              type: Type.OBJECT,
              properties: {
                level: { type: Type.STRING, description: "Short category name in Korean, max 4 chars (e.g., '구현', '탐색')" },
                score: { type: Type.INTEGER },
              },
            },
          },
        },
        required: ["totalScore", "rankEstimate", "strengths", "weaknesses", "recommendations", "detailedFeedback", "levelScores"],
      },
    },
  });

  if (response.text) {
    return JSON.parse(response.text) as AnalysisResult;
  }
  throw new Error("Failed to generate report");
};
